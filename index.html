<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Bubble Blast</title>
    <style>
      :root {
        --cols: 8;
        --rows: 10;
        --cell-gap: 8px; /* visual gap between bubbles */
        --board-padding: 12px;
        --ui-accent: #2bd3ff;
        --text: #072a3a;
      }

      * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(1200px 800px at 10% 10%, rgba(255,255,255,0.4), rgba(255,255,255,0) 40%),
                    radial-gradient(900px 700px at 90% 20%, rgba(59,193,255,0.18), rgba(59,193,255,0) 50%),
                    radial-gradient(800px 800px at 20% 90%, rgba(132,255,234,0.16), rgba(132,255,234,0) 50%),
                    linear-gradient(180deg, #c7f1ff 0%, #e9fbff 60%, #c6f5ff 100%);
        overflow: hidden;
      }

      /* Subtle animated ripples */
      body::before {
        content: "";
        position: absolute;
        inset: -20% -10% -10% -20%;
        background: radial-gradient(40% 20% at 50% 50%, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.0) 60%) repeat;
        opacity: 0.4;
        filter: blur(8px);
        animation: ripple 14s ease-in-out infinite;
        pointer-events: none;
      }
      @keyframes ripple {
        0% { transform: translate3d(0,0,0) scale(1); }
        50% { transform: translate3d(0,-1%,0) scale(1.03); }
        100% { transform: translate3d(0,0,0) scale(1); }
      }

      .app {
        position: relative;
        width: min(94vw, 760px);
        max-width: 760px;
        padding: 18px clamp(12px, 2.5vw, 22px);
        border-radius: 22px;
        background: rgba(255, 255, 255, 0.55);
        box-shadow: 0 12px 40px rgba(8, 77, 108, 0.18);
        backdrop-filter: blur(8px) saturate(1.2);
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 14px;
      }
      .title {
        display: flex;
        align-items: baseline;
        gap: 10px;
      }
      .title h1 {
        margin: 0;
        font-size: clamp(22px, 3.2vw, 34px);
        letter-spacing: 0.5px;
        color: #055069;
        text-shadow: 0 1px 0 #fff;
      }
      .subtitle {
        font-size: clamp(11px, 1.4vw, 13px);
        color: #3a6b7c;
        opacity: 0.85;
      }

      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .btn {
        appearance: none;
        border: 0;
        border-radius: 999px;
        padding: 10px 14px;
        font-weight: 700;
        font-size: 14px;
        color: #054a5d;
        background: linear-gradient(180deg, #e8fbff, #c6f5ff);
        box-shadow: 0 2px 0 #b4e6f0, 0 6px 18px rgba(24, 142, 175, 0.22) inset;
        cursor: pointer;
        transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.15s;
      }
      .btn:hover { filter: brightness(1.05); }
      .btn:active { transform: translateY(1px) scale(0.99); }
      .btn.primary { background: linear-gradient(180deg, #bff1ff, #7be7ff); color: #053949; box-shadow: 0 2px 0 #57d2e8, 0 8px 22px rgba(0, 168, 204, 0.25) inset; }
      .btn.secondary { background: linear-gradient(180deg, #ffe3f3, #ffd5ee); color: #6a0f46; box-shadow: 0 2px 0 #f6bfde, 0 8px 22px rgba(232, 66, 169, 0.18) inset; }

      .stats {
        display: flex;
        gap: 14px;
        align-items: center;
        font-weight: 800;
        color: #0a3d4f;
      }
      .pill {
        padding: 8px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 1px 0 rgba(3,36,45,0.08) inset;
        min-width: 92px;
        text-align: center;
      }

      .board-wrap {
        position: relative;
        display: grid;
        place-items: center;
      }
      #board {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 18px;
        padding: var(--board-padding);
        background: linear-gradient(180deg, rgba(255,255,255,0.65), rgba(255,255,255,0.5)),
                    radial-gradient(120% 100% at 10% 0%, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.0) 60%),
                    linear-gradient(180deg, #b6f2ff 0%, #c8fbff 70%, #a5eeff 100%);
        box-shadow: 0 10px 26px rgba(6,69,92,0.18), 0 3px 0 rgba(255,255,255,0.8) inset;
        overflow: hidden;
      }
      .grid-area {
        position: absolute;
        inset: var(--board-padding);
      }

      .bubble {
        position: absolute;
        width: var(--cell-size);
        height: var(--cell-size);
        border-radius: 999px;
        transform: translateZ(0);
        transition: top 220ms cubic-bezier(.22,1,.36,1), left 220ms cubic-bezier(.22,1,.36,1), transform 140ms ease;
        box-shadow: 0 8px 18px rgba(0,0,0,0.12), 0 2px 0 rgba(255,255,255,0.7) inset, 0 -3px 10px rgba(255,255,255,0.25) inset;
        will-change: top, left, transform;
        cursor: pointer;
      }
      .bubble:active { transform: scale(0.98); }

      /* Gloss highlight */
      .bubble::after {
        content: "";
        position: absolute;
        top: 10%;
        left: 18%;
        width: 44%;
        height: 38%;
        background: radial-gradient(60% 70% at 50% 50%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
        border-radius: 50%;
        filter: blur(1px);
        transform: rotate(-20deg);
      }

      /* Pop animation */
      @keyframes pop-burst {
        0% { transform: scale(1); opacity: 1; }
        60% { transform: scale(1.2); opacity: 0.9; }
        100% { transform: scale(0.7); opacity: 0; }
      }
      .popping { animation: pop-burst 180ms ease forwards; }

      /* Color themes for bubbles */
      .c-blue   { background: radial-gradient(120% 120% at 30% 30%, #c3f0ff 0%, #8ee6ff 35%, #4ad1ff 60%, #20aee3 100%); box-shadow: 0 0 16px rgba(23, 173, 255, 0.45), 0 2px 0 rgba(255,255,255,0.7) inset, 0 -3px 10px rgba(255,255,255,0.25) inset; }
      .c-green  { background: radial-gradient(120% 120% at 30% 30%, #d8ffe8 0%, #b5ffd7 35%, #69f3b1 60%, #36d893 100%); box-shadow: 0 0 16px rgba(62, 214, 160, 0.45), 0 2px 0 rgba(255,255,255,0.7) inset, 0 -3px 10px rgba(255,255,255,0.25) inset; }
      .c-pink   { background: radial-gradient(120% 120% at 30% 30%, #ffe1f4 0%, #ffc3e9 35%, #ff86cf 60%, #ff4fb0 100%); box-shadow: 0 0 16px rgba(255, 87, 173, 0.4), 0 2px 0 rgba(255,255,255,0.7) inset, 0 -3px 10px rgba(255,255,255,0.25) inset; }
      .c-yellow { background: radial-gradient(120% 120% at 30% 30%, #fff8d0 0%, #fff1a6 35%, #ffe168 60%, #ffc62b 100%); box-shadow: 0 0 16px rgba(255, 201, 71, 0.42), 0 2px 0 rgba(255,255,255,0.7) inset, 0 -3px 10px rgba(255,255,255,0.25) inset; }

      .footer {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #3a6b7c;
        opacity: 0.85;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.62);
        backdrop-filter: blur(3px);
        border-radius: 18px;
      }
      .overlay.show { display: flex; }
      .overlay-card {
        padding: 20px 22px;
        border-radius: 16px;
        background: linear-gradient(180deg, #ffffff, #f2fdff);
        box-shadow: 0 16px 40px rgba(6,69,92,0.2);
        text-align: center;
      }
      .overlay-card h3 { margin: 0 0 6px 0; }
      .overlay-card p { margin: 0 0 12px 0; color: #356175; }

      @media (max-width: 520px) {
        .stats .pill { min-width: 80px; }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="title">
          <h1>Bubble Blast</h1>
          <div class="subtitle">Water-bubble pop</div>
        </div>
        <div class="controls">
          <button id="btnAdventure" class="btn primary">Adventure</button>
          <button id="btnInfinite" class="btn secondary">Infinite</button>
        </div>
        <div class="stats">
          <div id="score" class="pill">Score: 0</div>
          <div id="timer" class="pill">∞</div>
        </div>
      </div>

      <div class="board-wrap">
        <div id="board">
          <div class="grid-area" id="grid"></div>
          <div id="overlay" class="overlay">
            <div class="overlay-card">
              <h3>Time's up!</h3>
              <p>Your score: <span id="finalScore">0</span></p>
              <button id="btnPlayAgain" class="btn primary">Play again</button>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        <div>Tip: Pop 2+ connected bubbles for points. Each bubble = +10.</div>
        <div>Modes: Adventure 60s • Infinite relax</div>
      </div>
    </div>

    <script>
      (function () {
        'use strict';

        // Config
        const NUM_ROWS = 10;
        const NUM_COLS = 8;
        const COLORS = ['blue','green','pink','yellow'];
        const COLOR_CLASS = {
          blue: 'c-blue',
          green: 'c-green',
          pink: 'c-pink',
          yellow: 'c-yellow'
        };
        const POINTS_PER_BUBBLE = 10;

        // DOM
        const boardEl = document.getElementById('board');
        const gridEl = document.getElementById('grid');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const overlayEl = document.getElementById('overlay');
        const finalScoreEl = document.getElementById('finalScore');
        const btnAdventure = document.getElementById('btnAdventure');
        const btnInfinite = document.getElementById('btnInfinite');
        const btnPlayAgain = document.getElementById('btnPlayAgain');

        // Layout sizing
        let cellSizePx = 48; // computed on layout
        function computeBoardSize() {
          const maxWidth = Math.min(window.innerWidth * 0.94, 760);
          // We want square-ish cells and the board to fit nicely.
          const availableWidth = maxWidth - 2 * 18; // app padding approx
          const boardMax = availableWidth; // board wrapper width
          // Leave padding inside board and gaps between cells visually via CSS gap effect baked into bubble size
          const innerPadding = 2 * parseFloat(getComputedStyle(boardEl).getPropertyValue('--board-padding')) || 24;
          const usable = boardMax - innerPadding;
          const sizeByWidth = Math.floor( (usable - (NUM_COLS - 1) * (getCellGap())) / NUM_COLS );
          const sizeByHeight = Math.floor( (usable * 1.25 - (NUM_ROWS - 1) * (getCellGap())) / NUM_ROWS );
          // Choose smaller to fully fit
          cellSizePx = Math.max(24, Math.min(sizeByWidth, sizeByHeight, 72));
          // Set board size precisely to fit grid
          const boardInnerW = NUM_COLS * cellSizePx + (NUM_COLS - 1) * getCellGap();
          const boardInnerH = NUM_ROWS * cellSizePx + (NUM_ROWS - 1) * getCellGap();
          boardEl.style.width = (boardInnerW + innerPadding) + 'px';
          boardEl.style.height = (boardInnerH + innerPadding) + 'px';
          gridEl.style.setProperty('--cell-size', cellSizePx + 'px');
          boardEl.style.setProperty('--cell-size', cellSizePx + 'px');
        }

        function getCellGap() {
          const cssGap = getComputedStyle(document.documentElement).getPropertyValue('--cell-gap');
          return parseInt(cssGap || '8', 10);
        }

        // Game state
        /** @type {(null | { id: number; color: string; })[][]} */
        let board = [];
        let idCounter = 1;
        /** @type {Map<number, HTMLElement>} */
        const idToEl = new Map();
        let isAnimating = false;
        let score = 0;
        let mode = 'infinite'; // 'adventure' | 'infinite'
        let timeLeft = Infinity; // in seconds
        let timerHandle = null;

        // Audio
        let audioCtx = null;
        let firstInteractionBound = false;
        function ensureAudio() {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
        }
        function bindFirstInteraction() {
          if (firstInteractionBound) return;
          firstInteractionBound = true;
          const unlock = () => {
            ensureAudio();
            window.removeEventListener('pointerdown', unlock);
            window.removeEventListener('keydown', unlock);
          };
          window.addEventListener('pointerdown', unlock, { once: true });
          window.addEventListener('keydown', unlock, { once: true });
        }
        function playPopSound(popCount) {
          if (!audioCtx) return;
          const now = audioCtx.currentTime;
          const voices = Math.min(8, Math.max(1, Math.floor(popCount / 2)));
          for (let v = 0; v < voices; v++) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const startFreq = 600 + Math.random() * 200 + v * 20;
            const endFreq = startFreq * (0.6 + Math.random() * 0.1);
            const t0 = now + v * 0.005;
            const t1 = t0 + 0.11 + Math.random() * 0.02;
            osc.type = 'sine';
            osc.frequency.setValueAtTime(startFreq, t0);
            osc.frequency.exponentialRampToValueAtTime(endFreq, t1);
            gain.gain.setValueAtTime(0.0001, t0);
            gain.gain.exponentialRampToValueAtTime(0.22 / voices, t0 + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, t1);
            osc.connect(gain).connect(audioCtx.destination);
            osc.start(t0);
            osc.stop(t1 + 0.02);
          }
        }

        // Utilities
        function randColor() { return COLORS[(Math.random() * COLORS.length) | 0]; }
        function inBounds(r, c) { return r >= 0 && r < NUM_ROWS && c >= 0 && c < NUM_COLS; }

        // Initialize board state
        function initBoard() {
          board = Array.from({ length: NUM_ROWS }, () => Array.from({ length: NUM_COLS }, () => null));
          idToEl.clear();
          gridEl.innerHTML = '';
          // Spawn initial bubbles
          for (let c = 0; c < NUM_COLS; c++) {
            for (let r = 0; r < NUM_ROWS; r++) {
              spawnBubbleAt(r, c, true /* instant */);
            }
          }
        }

        function bubbleTop(r) { return r * (cellSizePx + getCellGap()); }
        function bubbleLeft(c) { return c * (cellSizePx + getCellGap()); }

        function createBubbleEl(bubble, row, col) {
          const el = document.createElement('div');
          el.className = `bubble ${COLOR_CLASS[bubble.color]}`;
          el.style.width = cellSizePx + 'px';
          el.style.height = cellSizePx + 'px';
          el.style.top = bubbleTop(row) + 'px';
          el.style.left = bubbleLeft(col) + 'px';
          el.dataset.id = String(bubble.id);
          el.dataset.row = String(row);
          el.dataset.col = String(col);
          el.dataset.color = bubble.color;
          el.addEventListener('pointerdown', onBubblePointer, { passive: true });
          return el;
        }

        function spawnBubbleAt(row, col, instant = false) {
          const bubble = { id: idCounter++, color: randColor() };
          board[row][col] = bubble;
          const el = createBubbleEl(bubble, instant ? row : -1, col);
          idToEl.set(bubble.id, el);
          gridEl.appendChild(el);
          // Animate from above if not instant
          if (!instant) {
            requestAnimationFrame(() => {
              el.style.top = bubbleTop(row) + 'px';
            });
          }
          // Ensure dataset reflects the actual target grid position for interaction logic
          el.dataset.row = String(row);
          el.dataset.col = String(col);
        }

        function onBubblePointer(e) {
          if (isAnimating) return;
          const target = e.currentTarget;
          const r = parseInt(target.dataset.row, 10);
          const c = parseInt(target.dataset.col, 10);
          if (!inBounds(r, c)) return;
          const bubble = board[r][c];
          if (!bubble) return;
          const cluster = findCluster(r, c, bubble.color);
          if (cluster.length < 2) return; // need at least 2 to pop
          popCluster(cluster);
        }

        function findCluster(row, col, color) {
          /** @type {Array<[number, number]>} */
          const stack = [[row, col]];
          /** @type {boolean[][]} */
          const visited = Array.from({ length: NUM_ROWS }, () => Array.from({ length: NUM_COLS }, () => false));
          const cells = [];
          while (stack.length) {
            const [r, c] = stack.pop();
            if (!inBounds(r, c) || visited[r][c]) continue;
            visited[r][c] = true;
            const b = board[r][c];
            if (!b || b.color !== color) continue;
            cells.push([r, c]);
            stack.push([r+1, c], [r-1, c], [r, c+1], [r, c-1]);
          }
          return cells;
        }

        function popCluster(cells) {
          isAnimating = true;
          // Score
          const popped = cells.length;
          score += popped * POINTS_PER_BUBBLE;
          scoreEl.textContent = `Score: ${score}`;

          // Trigger pop animation and remove from state after
          for (const [r, c] of cells) {
            const b = board[r][c];
            if (!b) continue;
            const el = idToEl.get(b.id);
            if (!el) continue;
            el.classList.add('popping');
          }
          // Play sound
          playPopSound(cells.length);

          // After pop animation, clear and apply gravity
          setTimeout(() => {
            // Clear from state + DOM
            for (const [r, c] of cells) {
              const b = board[r][c];
              if (!b) continue;
              const el = idToEl.get(b.id);
              if (el && el.parentNode) el.parentNode.removeChild(el);
              idToEl.delete(b.id);
              board[r][c] = null;
            }
            applyGravityAndSpawn();
          }, 190);
        }

        function applyGravityAndSpawn() {
          // Compact each column downward
          const gap = getCellGap();
          const moves = [];
          for (let c = 0; c < NUM_COLS; c++) {
            let writeRow = NUM_ROWS - 1;
            for (let r = NUM_ROWS - 1; r >= 0; r--) {
              const b = board[r][c];
              if (b) {
                if (r !== writeRow) {
                  board[writeRow][c] = b;
                  board[r][c] = null;
                  moves.push({ id: b.id, fromR: r, toR: writeRow, col: c });
                }
                writeRow--;
              }
            }
            // Now spawn for remaining empty cells at top [0..writeRow]
            const spawnCount = writeRow + 1;
            for (let s = 0; s < spawnCount; s++) {
              const targetRow = writeRow - s;
              if (targetRow < 0) break;
              spawnBubbleAt(targetRow, c, false /* animate from top */);
            }
          }

          // Animate moved elements
          if (moves.length) {
            requestAnimationFrame(() => {
              for (const m of moves) {
                const el = idToEl.get(m.id);
                if (!el) continue;
                el.dataset.row = String(m.toR);
                el.style.top = (m.toR * (cellSizePx + gap)) + 'px';
              }
            });
          }

          // Finish
          setTimeout(() => { isAnimating = false; }, 260);
        }

        // Modes
        function setMode(newMode) {
          mode = newMode;
          if (timerHandle) { clearInterval(timerHandle); timerHandle = null; }
          if (mode === 'adventure') {
            timeLeft = 60;
            timerEl.textContent = '60s';
            timerHandle = setInterval(() => {
              timeLeft -= 1;
              if (timeLeft <= 0) {
                timerEl.textContent = '0s';
                clearInterval(timerHandle);
                timerHandle = null;
                onGameOver();
              } else {
                timerEl.textContent = timeLeft + 's';
              }
            }, 1000);
          } else {
            timeLeft = Infinity;
            timerEl.textContent = '∞';
          }
          overlayEl.classList.remove('show');
          resetGame();
          // Audio unlock on fresh start
          bindFirstInteraction();
        }

        function onGameOver() {
          isAnimating = true;
          finalScoreEl.textContent = String(score);
          overlayEl.classList.add('show');
        }

        function resetGame() {
          score = 0;
          scoreEl.textContent = 'Score: 0';
          initBoard();
          isAnimating = false;
        }

        // Input bindings
        btnAdventure.addEventListener('click', () => setMode('adventure'));
        btnInfinite.addEventListener('click', () => setMode('infinite'));
        btnPlayAgain.addEventListener('click', () => setMode('adventure'));

        // Resize handling
        function onResize() {
          computeBoardSize();
          // Reposition all bubbles based on new cell size
          const gap = getCellGap();
          idToEl.forEach((el) => {
            const r = parseInt(el.dataset.row, 10);
            const c = parseInt(el.dataset.col, 10);
            el.style.width = cellSizePx + 'px';
            el.style.height = cellSizePx + 'px';
            el.style.top = (r * (cellSizePx + gap)) + 'px';
            el.style.left = (c * (cellSizePx + gap)) + 'px';
          });
        }
        window.addEventListener('resize', onResize);

        // Boot
        computeBoardSize();
        initBoard();
        setMode('infinite');
        bindFirstInteraction();

      })();
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aqua Pop — Bubble Game</title>
  <style>
    :root{
      --bg1:#0a021a; --bg2:#12092f; --bg3:#0c1d40;
      --text:#f6f7fb; --muted:#a9b1c6;
      --cyan:#24e6ff; --mag:#ff4df2; --yel:#ffd36b; --grn:#58ffa8; --vio:#8d7bff; --org:#ff9f59;
      --glow:#74f1ff; --gold:#ffd36b;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{
      color:var(--text);
      display:flex; align-items:center; justify-content:center; padding:16px;
      background:
        radial-gradient(1200px 600px at 70% -10%, rgba(255,255,255,0.08), transparent 55%),
        linear-gradient(180deg, var(--bg2), var(--bg3));
    }
    /* Animated neon backdrop */
    body::before{
      content:"";
      position:fixed; inset:0; z-index:-2;
      background: conic-gradient(from 0deg, #1ee7ff, #6a5bff, #ff4df2, #ff9f59, #ffd36b, #58ffa8, #1ee7ff);
      opacity:0.18;
      animation: spinBg 26s linear infinite;
      filter: blur(80px) saturate(1.2);
    }
    @keyframes spinBg{ to{ transform:rotate(360deg) } }

    .wrap{width:100%; max-width:1100px; display:grid; grid-template-columns:1fr 320px; gap:14px}
    @media(max-width:920px){.wrap{grid-template-columns:1fr}}
    header{display:flex; align-items:center; gap:12px; margin-bottom:8px}
    .logo{width:56px; height:56px; border-radius:14px; background:linear-gradient(135deg,#7cfbff,#b9ffe6); color:#07202e; font-weight:900; display:grid; place-items:center}
    h1{font-size:22px; margin:0}

    .game{ background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.025)); border:1px solid rgba(255,255,255,0.09); border-radius:14px; padding:12px; box-shadow:0 10px 40px rgba(0,0,0,0.35)}
    #playArea{
      position:relative; height:520px; border-radius:12px; overflow:hidden;
      background:
        radial-gradient(800px 420px at 30% 10%, rgba(255,255,255,0.07), transparent 70%),
        radial-gradient(900px 560px at 90% 0%, rgba(255,255,255,0.06), transparent 70%),
        linear-gradient(180deg, rgba(120,200,255,0.08), rgba(0,0,0,0) 40%),
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.08)
    }
    /* Subtle board/grid overlay (Block Blast vibe) */
    #playArea::after{
      content:"";
      position:absolute; inset:0; pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0 1px, transparent 1px 36px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.04) 0 1px, transparent 1px 36px);
      mix-blend-mode: overlay; opacity:0.35;
    }
    /* Fever glow */
    #playArea.fever{
      box-shadow: 0 0 0 2px rgba(255,255,255,0.08), inset 0 0 32px rgba(116,241,255,0.35);
      outline: 2px solid rgba(116,241,255,0.28);
      animation: feverPulse 800ms ease-in-out alternate infinite;
    }
    @keyframes feverPulse{
      from{ filter: saturate(1) }
      to{ filter: saturate(1.35) brightness(1.05) }
    }

    .controls{ display:flex; gap:8px; align-items:center; margin:10px 0 }
    button{ cursor:pointer; padding:9px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.06); color:var(--text) }
    button.primary{ background:linear-gradient(90deg,#6ee7ff,#bdfcde); color:#06202b; border:none; font-weight:800 }
    button.ghost{ background:transparent }
    button.toggled{ outline:2px solid #6ee7ff33 }

    .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:12px }
    .sidebar{ display:flex; flex-direction:column; gap:12px }
    .row{ display:flex; justify-content:space-between; align-items:center }
    .muted{ color:var(--muted); font-size:13px }
    .big{ font-size:34px; font-weight:900; color:var(--gold) }

    /* Bubbles and Tiles */
    .bubble{
      position:absolute; bottom:-120px; left:0; width:80px; height:80px; border-radius:50%; pointer-events:auto; user-select:none;
      background:
        radial-gradient(130% 130% at 28% 28%, rgba(255,255,255,0.9), rgba(255,255,255,0.22) 28%, rgba(255,255,255,0.08) 55%, rgba(255,255,255,0.03) 72%, rgba(255,255,255,0) 75%),
        conic-gradient(from 0deg, #24e6ff, #8d7bff, #ff4df2, #ff9f59, #ffd36b, #58ffa8, #24e6ff);
      box-shadow:
        inset 0 6px 16px rgba(255,255,255,0.4),
        inset 0 -12px 28px rgba(86,180,255,0.25),
        0 8px 24px rgba(0,0,0,0.45);
      backdrop-filter: blur(2px);
      animation:
        floatUp var(--dur,9s) linear forwards,
        bobX var(--bob,6s) ease-in-out infinite;
    }
    /* “Tile” bonus (Block Blast reference) */
    .bubble.blocky{
      border-radius:14px;
      background:
        linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0) 40%),
        linear-gradient(145deg, rgba(255,255,255,0.16), rgba(255,255,255,0) 60%),
        linear-gradient(135deg, #ff9f59, #ff4df2 35%, #8d7bff 65%, #24e6ff);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,0.45),
        0 10px 26px rgba(0,0,0,0.5),
        0 0 0 2px rgba(255,255,255,0.08);
    }

    /* Color accents */
    .c-cyan{ filter: drop-shadow(0 4px 10px rgba(36,230,255,0.45)) }
    .c-mag{  filter: drop-shadow(0 4px 10px rgba(255,77,242,0.45)) }
    .c-yellow{ filter: drop-shadow(0 4px 10px rgba(255,211,107,0.42)) }
    .c-green{ filter: drop-shadow(0 4px 10px rgba(88,255,168,0.45)) }
    .c-vio{   filter: drop-shadow(0 4px 10px rgba(141,123,255,0.45)) }
    .c-org{   filter: drop-shadow(0 4px 10px rgba(255,159,89,0.45)) }

    .bubble.rainbow{ filter:hue-rotate(60deg) saturate(1.6); box-shadow: inset 0 6px 16px rgba(255,255,255,0.45), inset 0 -10px 24px rgba(180,255,220,0.35), 0 8px 24px rgba(0,0,0,0.52) }

    @keyframes floatUp{ to{ transform:translateY(calc(-100% - 650px)) scale(0.98); opacity:0.98 } }
    @keyframes bobX{
      0%{ transform: translateX(-8px) }
      50%{ transform: translateX(8px) }
      100%{ transform: translateX(-8px) }
    }
    @keyframes popOut{ to{ transform:scale(1.2); opacity:0 } }

    .ripple{ position:absolute; border-radius:50%; border:2px solid rgba(190,245,255,0.9); width:10px; height:10px; opacity:0.95; pointer-events:none; animation:ripple 600ms ease-out forwards }
    @keyframes ripple{ to{ transform:scale(7); opacity:0 } }

    /* Particle burst */
    .burst{ position:absolute; width:0; height:0; pointer-events:none; }
    .spark{
      position:absolute; width:6px; height:6px; border-radius:50%;
      background: currentColor; box-shadow:0 0 10px currentColor;
      transform: translate(-50%,-50%);
      animation: spark 620ms ease-out forwards;
    }
    @keyframes spark{ to{ transform: translate(var(--dx), var(--dy)) scale(0.6); opacity:0 } }

    .floatScore{ position:absolute; color:#d2f8ff; font-weight:900; font-size:16px; text-shadow:0 2px 8px rgba(0,0,0,0.6); animation:floatScore 900ms ease-out forwards; pointer-events:none }
    @keyframes floatScore{ to{ transform:translateY(-42px); opacity:0 } }

    .tabs{ display:flex; gap:8px; margin:8px 0 }
    .tabs button{ padding:8px 12px }
    .tabs .active{ background:linear-gradient(90deg,#6ee7ff,#bdfcde); color:#06202b; font-weight:800 }

    .bar{ display:flex; gap:12px; align-items:center }
    .sep{ width:1px; height:28px; background:rgba(255,255,255,0.12) }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <header>
        <div class="logo">AP</div>
        <div>
          <h1>Aqua Pop — Satisfying Bubble Game</h1>
          <div class="muted">Pop as many bubbles as you can. Two modes: <strong>Adventure</strong> (timed) and <strong>Infinite</strong> (relax). Neon edition.</div>
        </div>
      </header>

      <div class="tabs" role="tablist" aria-label="Game modes">
        <button id="tabAdventure" class="active" role="tab" aria-selected="true">Adventure (Timed)</button>
        <button id="tabInfinite" role="tab" aria-selected="false">Infinite (Relax)</button>
      </div>

      <div id="playArea" aria-label="play area"></div>

      <div class="controls">
        <div class="bar">
          <button id="startBtn" class="primary">Start</button>
          <button id="pauseBtn">Pause</button>
          <button id="resetBtn" class="ghost">Reset</button>
          <div class="sep"></div>
          <div class="muted">Score: <span id="score">0</span></div>
          <div class="muted">Combo: <span id="combo">0</span></div>
          <div id="timerWrap" class="muted">Time: <span id="time">45</span>s</div>
        </div>
        <div style="margin-left:auto" class="muted">Tip: blocky tiles = bonus; neon bubbles = combo fuel</div>
      </div>

      <div style="display:flex; gap:12px; align-items:stretch">
        <div class="panel" style="flex:1">
          <div class="row"><div class="muted">High Score (Adventure)</div><div id="hsAdv" class="big">0</div></div>
          <div class="row"><div class="muted">High Score (Infinite)</div><div id="hsInf" class="big">0</div></div>
        </div>
        <div class="panel" style="width:360px">
          <div class="row"><strong>Settings</strong><span class="muted">v1.1 Neon</span></div>
          <div class="muted" style="margin-top:6px">Adventure duration: <span id="durLabel">45</span>s</div>
          <input id="duration" type="range" min="20" max="120" value="45" style="width:100%">
          <div class="muted" style="margin-top:6px">Spawn rate (higher = more bubbles): <span id="spawnLabel">1.0</span>x</div>
          <input id="spawn" type="range" min="0.5" max="3" step="0.1" value="1" style="width:100%">
          <div class="muted" style="margin-top:6px">Max bubbles on screen: <span id="maxLabel">18</span></div>
          <input id="maxBubbles" type="range" min="6" max="40" value="18" style="width:100%">
          <div class="muted" style="margin-top:6px">Bubble size range (px)</div>
          <div class="row" style="gap:8px">
            <label class="muted">Min <input id="minSize" type="number" value="38" min="20" max="140" style="width:70px"></label>
            <label class="muted">Max <input id="maxSize" type="number" value="96" min="30" max="180" style="width:70px"></label>
          </div>
        </div>
      </div>

    </div>

    <aside class="sidebar">
      <div class="panel">
        <strong>How to Play</strong>
        <ul class="muted">
          <li><b>Adventure:</b> Pop fast for score. Rainbow and blocky give bonuses.</li>
          <li><b>Infinite:</b> Just vibe and pop. No timer.</li>
          <li>Build combo to trigger short <b>Fever</b> mode (extra glow and score x2).</li>
          <li>Adjust settings for pace and difficulty.</li>
        </ul>
      </div>
      <div class="panel">
        <strong>Share</strong>
        <div class="muted">Tell friends or post your score.</div>
        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap">
          <button id="shareBtn">Share score</button>
          <button id="copyBtn">Copy game file</button>
        </div>
        <div class="muted" style="margin-top:8px">Paste into <code>index.html</code> and host anywhere.</div>
      </div>
      <div class="panel">
        <strong>Credits</strong>
        <div class="muted">HTML, CSS, and JavaScript. Audio via WebAudio. Neon vibes inspired by block puzzlers.</div>
      </div>
    </aside>
  </div>

  <script>
    // === Aqua Pop Game Logic (Neon) ===
    const playArea = document.getElementById('playArea');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const timeEl = document.getElementById('time');
    const timerWrap = document.getElementById('timerWrap');
    const hsAdvEl = document.getElementById('hsAdv');
    const hsInfEl = document.getElementById('hsInf');
    const shareBtn = document.getElementById('shareBtn');
    const copyBtn = document.getElementById('copyBtn');

    const tabAdventure = document.getElementById('tabAdventure');
    const tabInfinite = document.getElementById('tabInfinite');

    const duration = document.getElementById('duration');
    const durLabel = document.getElementById('durLabel');
    const spawn = document.getElementById('spawn');
    const spawnLabel = document.getElementById('spawnLabel');
    const maxBubbles = document.getElementById('maxBubbles');
    const maxLabel = document.getElementById('maxLabel');
    const minSize = document.getElementById('minSize');
    const maxSize = document.getElementById('maxSize');

    let ctx; // audio context
    const game = {
      mode:'adventure', running:false, paused:false,
      score:0, combo:0, timeLeft:45,
      spawnHandle:null, timerHandle:null,
      highAdv: Number(localStorage.getItem('ap_hs_adv')||0),
      highInf: Number(localStorage.getItem('ap_hs_inf')||0),
      feverUntil: 0
    };
    hsAdvEl.textContent = game.highAdv; hsInfEl.textContent = game.highInf;

    function setMode(m){
      if(game.running){ return; }
      game.mode = m;
      tabAdventure.classList.toggle('active', m==='adventure');
      tabInfinite.classList.toggle('active', m==='infinite');
      timerWrap.style.display = (m==='adventure') ? 'inline-flex' : 'none';
    }

    tabAdventure.onclick = ()=> setMode('adventure');
    tabInfinite.onclick = ()=> setMode('infinite');

    // Settings bindings
    durLabel.textContent = duration.value;
    duration.oninput = ()=>{ durLabel.textContent = duration.value; if(!game.running) timeEl.textContent = duration.value; };
    spawnLabel.textContent = spawn.value; spawn.oninput = ()=>{ spawnLabel.textContent = spawn.value };
    maxLabel.textContent = maxBubbles.value; maxBubbles.oninput = ()=>{ maxLabel.textContent = maxBubbles.value };

    // Audio helpers
    function popSound(){
      try{
        if(!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o1 = ctx.createOscillator();
        const o2 = ctx.createOscillator();
        const g = ctx.createGain();
        o1.type='sine'; o2.type='triangle';
        const base = 640 + Math.random()*500;
        o1.frequency.setValueAtTime(base, ctx.currentTime);
        o2.frequency.setValueAtTime(base*0.5, ctx.currentTime);
        const end = ctx.currentTime + 0.12;
        o1.frequency.exponentialRampToValueAtTime(180, end);
        o2.frequency.exponentialRampToValueAtTime(130, end);
        g.gain.setValueAtTime(0.001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.28, ctx.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.001, end);
        const comp = ctx.createDynamicsCompressor();
        comp.attack.setValueAtTime(0.003, ctx.currentTime);
        comp.release.setValueAtTime(0.05, ctx.currentTime);
        o1.connect(g); o2.connect(g); g.connect(comp); comp.connect(ctx.destination);
        o1.start(); o2.start();
        o1.stop(end); o2.stop(end);
      }catch(e){}
    }

    function vibrate(ms){ try{ if(navigator.vibrate) navigator.vibrate(ms) }catch(e){} }

    function rand(min,max){ return Math.random()*(max-min)+min }
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)] }

    // Particle burst
    function burst(x,y,color){
      const rect = playArea.getBoundingClientRect();
      const b = document.createElement('div'); b.className='burst';
      b.style.left = (x-rect.left)+'px'; b.style.top = (y-rect.top)+'px';
      for(let i=0;i<12;i++){
        const s = document.createElement('div'); s.className='spark';
        const ang = Math.random()*Math.PI*2;
        const dist = 36 + Math.random()*54;
        s.style.setProperty('--dx', Math.cos(ang)*dist+'px');
        s.style.setProperty('--dy', Math.sin(ang)*dist+'px');
        s.style.color = color;
        b.appendChild(s);
      }
      playArea.appendChild(b);
      setTimeout(()=> b.remove(), 700);
    }

    function makeRipple(x,y){
      const r = document.createElement('div'); r.className='ripple';
      const rect = playArea.getBoundingClientRect();
      r.style.left = (x-rect.left-5)+'px'; r.style.top = (y-rect.top-5)+'px';
      playArea.appendChild(r);
      setTimeout(()=> r.remove(), 650);
    }

    function floatText(text,x,y,color){
      const t = document.createElement('div'); t.className='floatScore'; t.textContent=text;
      const rect = playArea.getBoundingClientRect();
      t.style.left = (x-rect.left)+'px'; t.style.top = (y-rect.top)+'px';
      if(color) t.style.color = color;
      playArea.appendChild(t);
      setTimeout(()=> t.remove(), 950);
    }

    function triggerFever(){
      const now = performance.now();
      game.feverUntil = now + 4000;
      playArea.classList.add('fever');
      setTimeout(()=> playArea.classList.remove('fever'), 4000);
      // Small bonus burst
      for(let i=0;i<4;i++) setTimeout(spawnBubble, i*80);
    }

    const colorClasses = [
      {cls:'c-cyan',   color:'#24e6ff'},
      {cls:'c-mag',    color:'#ff4df2'},
      {cls:'c-yellow', color:'#ffd36b'},
      {cls:'c-green',  color:'#58ffa8'},
      {cls:'c-vio',    color:'#8d7bff'},
      {cls:'c-org',    color:'#ff9f59'}
    ];

    function spawnBubble(){
      if(!game.running || game.paused) return;
      const current = playArea.querySelectorAll('.bubble').length;
      const max = Number(maxBubbles.value);
      if(current >= max) return;

      const b = document.createElement('div'); b.className = 'bubble';
      const minS = Math.min(Number(minSize.value), Number(maxSize.value));
      const maxS = Math.max(Number(minSize.value), Number(maxSize.value));
      const size = rand(minS, maxS);
      b.style.width = size+'px'; b.style.height = size+'px';

      // Color tag
      const col = pick(colorClasses);
      b.classList.add(col.cls);
      // 14% chance of rainbow, 10% chance of blocky tile
      const isRainbow = Math.random() < 0.14;
      const isBlocky = !isRainbow && Math.random() < 0.10;
      if(isRainbow) b.classList.add('rainbow');
      if(isBlocky) b.classList.add('blocky');

      // place bottom with random x
      const rect = playArea.getBoundingClientRect();
      const x = rand(8, Math.max(10, rect.width - size - 8));
      b.style.left = x+'px';

      // duration depends on size and spawn slider; add slight wobble speed
      const sp = Number(spawn.value);
      const baseDur = 7 + (size/36);
      const dur = Math.max(4, baseDur / (0.5 + sp/1.5));
      b.style.setProperty('--dur', dur+'s');
      b.style.setProperty('--bob', (5 + Math.random()*4)+'s');

      // Click handler
      b.addEventListener('pointerdown', (ev)=>{
        ev.stopPropagation();
        const now = performance.now();
        const inFever = now < game.feverUntil;
        const ptsBase = isRainbow ? 5 : (isBlocky ? 3 : 1);
        const mult = inFever ? 2 : 1;
        const bonusCombo = 1 + Math.floor(game.combo/12);
        const pts = ptsBase * bonusCombo * mult;

        game.score += pts;
        game.combo += 1;
        scoreEl.textContent = game.score; comboEl.textContent = game.combo;

        popSound(); vibrate(10);

        // Effects
        b.style.animation = 'popOut 180ms ease-out forwards';
        makeRipple(ev.clientX, ev.clientY);
        floatText(`+${pts}`, ev.clientX, ev.clientY, col.color);
        burst(ev.clientX, ev.clientY, col.color);

        // Fever trigger each 10-combo step
        if(game.combo>0 && game.combo % 10 === 0) triggerFever();

        setTimeout(()=> b.remove(), 160);
      }, {passive:true});

      // miss cleanup
      b.addEventListener('animationend', ()=>{ b.remove() });

      playArea.appendChild(b);
    }

    function startGame(){
      if(game.running){ return }
      game.running = true; game.paused=false; pauseBtn.textContent='Pause';
      game.score=0; game.combo=0; scoreEl.textContent='0'; comboEl.textContent='0';
      game.feverUntil = 0; playArea.classList.remove('fever');
      if(game.mode==='adventure'){ game.timeLeft = Number(duration.value); timeEl.textContent = game.timeLeft; }

      // timers
      const spawnMs = Math.max(140, 900 / Number(spawn.value));
      game.spawnHandle = setInterval(spawnBubble, spawnMs);
      // initial burst
      for(let i=0;i<7;i++) setTimeout(spawnBubble, i*120);

      if(game.mode==='adventure'){
        game.timerHandle = setInterval(()=>{
          if(!game.paused){
            game.timeLeft -= 1; timeEl.textContent = game.timeLeft;
            if(game.timeLeft<=0){ endGame(); }
          }
        }, 1000);
      }
    }

    function pauseGame(){
      if(!game.running) return;
      game.paused = !game.paused; pauseBtn.textContent = game.paused ? 'Resume' : 'Pause';
    }

    function endGame(){
      clearInterval(game.spawnHandle); clearInterval(game.timerHandle);
      game.running=false; game.paused=false; game.feverUntil=0; playArea.classList.remove('fever');
      // cleanup remain bubbles
      playArea.querySelectorAll('.bubble,.ripple,.floatScore,.burst').forEach(n=>n.remove());
      // high scores
      if(game.mode==='adventure'){
        if(game.score>game.highAdv){ game.highAdv=game.score; localStorage.setItem('ap_hs_adv', String(game.highAdv)); hsAdvEl.textContent=game.highAdv; }
      } else {
        if(game.score>game.highInf){ game.highInf=game.score; localStorage.setItem('ap_hs_inf', String(game.highInf)); hsInfEl.textContent=game.highInf; }
      }
      // message
      const r = playArea.getBoundingClientRect();
      floatText('Game Over', r.left + playArea.clientWidth/2, r.top + 48, '#ffd36b');
    }

    function resetGame(){
      clearInterval(game.spawnHandle); clearInterval(game.timerHandle);
      game.running=false; game.paused=false; game.feverUntil=0; playArea.classList.remove('fever');
      pauseBtn.textContent='Pause';
      scoreEl.textContent='0'; comboEl.textContent='0';
      if(game.mode==='adventure') timeEl.textContent = duration.value;
      playArea.querySelectorAll('.bubble,.ripple,.floatScore,.burst').forEach(n=>n.remove());
    }

    // Clicking empty area breaks combo gently
    playArea.addEventListener('pointerdown', (ev)=>{
      if(!game.running) return;
      if(!(ev.target.classList && ev.target.classList.contains('bubble'))){
        game.combo = Math.max(0, game.combo-1); comboEl.textContent=game.combo; vibrate(4);
      }
    });

    startBtn.onclick = startGame; pauseBtn.onclick = pauseGame; resetBtn.onclick = resetGame;

    // Keyboard helpers
    document.addEventListener('keydown', (e)=>{
      if(e.key===' '){ e.preventDefault(); if(!game.running) startGame(); else pauseGame(); }
      if(e.key==='r') resetGame();
      if(e.key==='1') setMode('adventure');
      if(e.key==='2') setMode('infinite');
    });

    // Share & copy helpers
    shareBtn.onclick = ()=>{
      const text = `I scored ${game.score} in Aqua Pop (${game.mode} mode)!`;
      if(navigator.share){ navigator.share({title:'Aqua Pop', text, url: location.href}) }
      else{ const u = 'https://twitter.com/intent/tweet?text='+encodeURIComponent(text); window.open(u,'_blank'); }
    };
    copyBtn.onclick = async ()=>{
      try{ const html = '<!doctype html>\\n'+document.documentElement.outerHTML; await navigator.clipboard.writeText(html); alert('Copied full game HTML to clipboard. Paste into index.html'); }catch(e){ alert('Copy failed. Try Ctrl/Cmd+A then copy from View Source.'); }
    };

    // Ambient gentle bubbles if idle (for vibe)
    let ambient = setInterval(()=>{ if(!game.running && Math.random()<0.4) spawnBubble() }, 1400);
  </script>
</body>
</html>